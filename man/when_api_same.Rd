% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search.R
\name{when_api_same}
\alias{when_api_same}
\alias{when_fun_exists}
\title{Compare function existence and APIs across package versions}
\usage{
when_api_same(fun, package, current_fun = NULL, search = c("binary",
  "forward", "backward", "all", "parallel"), report = c("full", "brief"),
  quiet = TRUE, progress = interactive() && search != "parallel",
  min_version = NULL, max_version = NULL, ...)

when_fun_exists(fun, package, search = c("binary", "forward", "backward",
  "all", "parallel"), report = c("full", "brief"), quiet = TRUE,
  progress = interactive() && search != "parallel", min_version = NULL,
  max_version = NULL, ...)
}
\arguments{
\item{fun}{Function name as a character string. \code{fun} can be an S3 method; S4 methods aren't yet supported.}

\item{package}{Package. Alternatively, specify the function name as e.g. \code{"package::function"}.}

\item{current_fun}{Current function for comparison. By default, \code{fun} in the current version of
the package (which is assumed to be available in a standard library location). If provided, this
must be an actual function, not a character string. You can use
\code{\link[=fun_at]{fun_at()}} for this.}

\item{search}{"binary", "forward", "backward", "all" or "parallel". See Search strategies.}

\item{report}{"brief" or "full". See Value.}

\item{quiet}{Logical. Try to minimize output from package installation. (Some output comes from \code{R CMD INSTALL} and may be unavoidable.)}

\item{progress}{Print a progress bar.}

\item{min_version}{Lowest version to check.}

\item{max_version}{Highest version to check.}

\item{...}{Arguments passed to \code{\link[versions:install.versions]{versions::install.versions()}} or
\code{\link[remotes:install_version]{remotes::install_version()}}, and thence to \code{\link[=install.packages]{install.packages()}}.}
}
\value{
If \code{report} is "brief", the earliest "known good" version.
Otherwise, a data frame of versions with a full results column.
}
\description{
\code{when_api_same} reports package versions where the API of a function was the same as now (or
the same as \code{current_fun}).

\code{when_fun_exists} reports package versions where a function exists.
}
\details{
"Same API" means having the same function arguments, as reported by \code{\link[=formals]{formals()}}.
}
\section{Speed}{

This function may download and install multiple versions from MRAN, so it is likely to be slow
when first used (and even afterwards if library loading is slow). Using \code{search = "parallel"}
may help, but not if the network is the bottleneck: see
\href{here}{https://hughjonesd.github.io/apicheck/performance2.html} for details.
}

\section{Search strategies}{

\itemize{
\item \code{"forward"} (\code{"backward"}) searches incrementally from the earliest (latest) version.
\item \code{"binary"} does a binary search from the midpoint.
}

These
strategies assume that API changes happen just once - i.e. once a function exists or API is the same as now,
it will stay so in future versions. This allows them to stop before searching every version.

\itemize{
\item \code{"all"} searches every version.
\item \code{"parallel"} searches every version in parallel using \code{\link[parallel:parLapply]{parallel::parLapply()}}.
}
For parallel search, you can set up your own parallel
cluster by using \code{\link[parallel:setDefaultCluster]{parallel::setDefaultCluster()}}; otherwise one will be created, using
\code{getOption("cl.cores")} cores if that is set. If you
set up your own cluster, it will not be stopped automatically (see
\code{\link[parallel:stopCluster]{parallel::stopCluster()}}).
}

\examples{
\dontrun{
when_api_same("read.dta", "foreign")
}
\dontrun{
when_fun_exists('read.dta', 'foreign')
}
}
